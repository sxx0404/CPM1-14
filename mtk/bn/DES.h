#ifndef CDES_H_CAESAR__DEF
#define CDES_H_CAESAR__DEF
#include <stdlib.h>

#include "stdafx.h"

#include <stdint.h>
#include <stdio.h>
#include <string.h>
#if 1
#define  ENCRYPT 0
#define  DECRYPT 1
#define ECB         0
#define  CBC        1
#endif

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus
	typedef  uchar    (*PSubKey)[16][48];

	//Pad填充的模式
	enum
	{
		PAD_ISO_1 =	0,	//ISO_1填充：数据长度不足8比特的倍数，以0x00补足，如果为8比特的倍数，补8个0x00
		PAD_ISO_2,		//ISO_2填充：数据长度不足8比特的倍数，以0x80,0x00..补足，如果为8比特的倍数，补0x80,0x00..0x00
		PAD_PKCS_7		//PKCS7填充：数据长度除8余数为n,以(8-n)补足为8的倍数
	};

/*******************************************************************/
/*
  函 数 名 称:	RunPad
  功 能 描 述：	根据协议对加密前的数据进行填充
  参 数 说 明：	bType	:类型：PAD类型
				In		:数据串指针
				Out		:填充输出串指针
				datalen	:数据的长度
				padlen	:(in,out)输出buffer的长度，填充后的长度

  返回值 说明：	uchar	:是否填充成功
  作       者:	邹德强
  修 改 历 史：	2004.7.12日，更改内存写入位置错误

  更 新 日 期：	2003.12.19
*******************************************************************/
	//static uchar	RunPad(int nType,const char* In,unsigned datalen,char* Out,unsigned& padlen);





/*******************************************************************/
/*
  函 数 名 称:	RunDes
  功 能 描 述：	执行DES算法对文本加解密
  参 数 说 明：	bType	:类型：加密ENCRYPT，解密DECRYPT
				bMode	:模式：ECB,CBC
				In		:待加密串指针
				Out		:待输出串指针
				datalen	:待加密串的长度，同时Out的缓冲区大小应大于或者等于datalen
				Key		:密钥(可为8位,16位,24位)支持3密钥
				keylen	:密钥长度，多出24位部分将被自动裁减

  返回值 说明：	uchar	:是否加密成功
  作       者:	邹德强
  修 改 历 史：	2004.7.6,修改ECB/CBC 3key模式bug

  更 新 日 期：	2003.12.19
*******************************************************************/

#if 0
class CDES
{
public:
	CDES();
	virtual ~CDES();

	//加密解密
	enum
	{
		ENCRYPT	=	0,	//加密
		DECRYPT			//解密
	};

	//DES算法的模式
	enum
	{
		ECB		=	0,	//ECB模式
		CBC				//CBC模式
	};







};

#endif
#endif

extern void DesCbc2keyEncode(uchar *data, int len, uchar *key, const char* cveci);
extern void DesCbc2keyDecode(uchar *data, int len, uchar *key, const char* cveci);
extern void ThDesCbc2keyEncode(uchar *data, int len, uchar *key, const char* cveci);
extern void ThDesCbc2keyDecode(uchar *data, int len, uchar *key, const char* cveci);

#ifdef __cplusplus
}
#endif // __cplusplus
//DES算法相应描述：

/*
如何实现DES算法

原文：Matthew Fischer

DES( Data Encryption Standard)算法，于1977年得到美国政府的正式许可，是一种用56位密钥来加密64位数据的方法。DES算法以被应用于许多需要安全加密的场合。（如：UNIX的密码算法就是以DES算法为基础的）。下面是关于如何实现DES算法的语言性描述，如果您要其源代码，可以到Http//Assassin.yeah.net下载，后者您有任何问题也可以写信给我（Assassin@ynmail.com）。

1-1、变换密钥

取得64位的密钥，每个第8位作为奇偶校验位。

1-2、变换密钥。

1-2-1、舍弃64位密钥中的奇偶校验位，根据下表（PC-1）进行密钥变换得到56位的密钥，在变换中，奇偶校验位以被舍弃。

Permuted Choice 1 (PC-1)

57 49 41 33 25 17 9

1 58 50 42 34 26 18

10 2 59 51 43 35 27

19 11 3 60 52 44 36

63 55 47 39 31 23 15

7 62 54 46 38 30 22

14 6 61 53 45 37 29

21 13 5 28 20 12 4

1-2-2、将变换后的密钥分为两个部分，开始的28位称为C[0]，最后的28位称为D[0]。

1-2-3、生成16个子密钥，初始I=1。

1-2-3-1、同时将C[I]、D[I]左移1位或2位，根据I值决定左移的位数。见下表

I： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16

左移位数： 1 1 2 2 2 2 2 2 1 2 2 2 2 2 2 1

1-2-3-2、将C[I]D[I]作为一个整体按下表（PC-2）变换，得到48位的K[I]

　

Permuted Choice 2 (PC-2)

14 17 11 24 1 5

3 28 15 6 21 10

23 19 12 4 26 8

16 7 27 20 13 2

41 52 31 37 47 55

30 40 51 45 33 48

44 49 39 56 34 53

46 42 50 36 29 32

1-2-3-3、从1-2-3-1处循环执行，直到K[16]被计算完成。


2、处理64位的数据

2-1、取得64位的数据，如果数据长度不足64位，应该将其扩展为64位（例如补零）

2-2、将64位数据按下表变换（IP）

Initial Permutation (IP)

58 50 42 34 26 18 10 2

60 52 44 36 28 20 12 4

62 54 46 38 30 22 14 6

64 56 48 40 32 24 16 8

57 49 41 33 25 17 9 1

59 51 43 35 27 19 11 3

61 53 45 37 29 21 13 5

63 55 47 39 31 23 15 7

2-3、将变换后的数据分为两部分，开始的32位称为L[0]，最后的32位称为R[0]。

2-4、用16个子密钥加密数据，初始I=1。

2-4-1、将32位的R[I-1]按下表（E）扩展为48位的E[I-1]

Expansion (E)

32 1 2 3 4 5

4 5 6 7 8 9

8 9 10 11 12 13

12 13 14 15 16 17

16 17 18 19 20 21

20 21 22 23 24 25

24 25 26 27 28 29

28 29 30 31 32 1

2-4-2、异或E[I-1]和K[I]，即E[I-1] XOR K[I]

2-4-3、将异或后的结果分为8个6位长的部分，第1位到第6位称为B[1]，第7位到第12位称为B[2]，依此类推，第43位到第48位称为B[8]。

2-4-4、按S表变换所有的B[J]，初始J=1。所有在S表的值都被当作4位长度处理。

2-4-4-1、将B[J]的第1位和第6位组合为一个2位长度的变量M，M作为在S[J]中的行号。

2-4-4-2、将B[J]的第2位到第5位组合，作为一个4位长度的变量N，N作为在S[J]中的列号。

2-4-4-3、用S[J][M][N]来取代B[J]。

Substitution Box 1 (S[1])

14 4 13 1 2 15 11 8 3 10 6 12 5 9 0 7

0 15 7 4 14 2 13 1 10 6 12 11 9 5 3 8

4 1 14 8 13 6 2 11 15 12 9 7 3 10 5 0

15 12 8 2 4 9 1 7 5 11 3 14 10 0 6 13

S[2]

15 1 8 14 6 11 3 4 9 7 2 13 12 0 5 10

3 13 4 7 15 2 8 14 12 0 1 10 6 9 11 5

0 14 7 11 10 4 13 1 5 8 12 6 9 3 2 15

13 8 10 1 3 15 4 2 11 6 7 12 0 5 14 9

S[3]

10 0 9 14 6 3 15 5 1 13 12 7 11 4 2 8

13 7 0 9 3 4 6 10 2 8 5 14 12 11 15 1

13 6 4 9 8 15 3 0 11 1 2 12 5 10 14 7

1 10 13 0 6 9 8 7 4 15 14 3 11 5 2 12

S[4]

7 13 14 3 0 6 9 10 1 2 8 5 11 12 4 15

13 8 11 5 6 15 0 3 4 7 2 12 1 10 14 9

10 6 9 0 12 11 7 13 15 1 3 14 5 2 8 4

3 15 0 6 10 1 13 8 9 4 5 11 12 7 2 14

S[5]

2 12 4 1 7 10 11 6 8 5 3 15 13 0 14 9

14 11 2 12 4 7 13 1 5 0 15 10 3 9 8 6

4 2 1 11 10 13 7 8 15 9 12 5 6 3 0 14

11 8 12 7 1 14 2 13 6 15 0 9 10 4 5 3

S[6]

12 1 10 15 9 2 6 8 0 13 3 4 14 7 5 11

10 15 4 2 7 12 9 5 6 1 13 14 0 11 3 8

9 14 15 5 2 8 12 3 7 0 4 10 1 13 11 6

4 3 2 12 9 5 15 10 11 14 1 7 6 0 8 13

S[7]

4 11 2 14 15 0 8 13 3 12 9 7 5 10 6 1

13 0 11 7 4 9 1 10 14 3 5 12 2 15 8 6

1 4 11 13 12 3 7 14 10 15 6 8 0 5 9 2

6 11 13 8 1 4 10 7 9 5 0 15 14 2 3 12

S[8]

13 2 8 4 6 15 11 1 10 9 3 14 5 0 12 7

1 15 13 8 10 3 7 4 12 5 6 11 0 14 9 2

7 11 4 1 9 12 14 2 0 6 10 13 15 3 5 8

2 1 14 7 4 10 8 13 15 12 9 0 3 5 6 11

2-4-4-4、从2-4-4-1处循环执行，直到B[8]被替代完成。

2-4-4-5、将B[1]到B[8]组合，按下表（P）变换，得到P。

Permutation P

16 7 20 21

29 12 28 17

1 15 23 26

5 18 31 10

2 8 24 14

32 27 3 9

19 13 30 6

22 11 4 25

2-4-6、异或P和L[I-1]结果放在R[I]，即R[I]=P XOR L[I-1]。

2-4-7、L[I]=R[I-1]

2-4-8、从2-4-1处开始循环执行，直到K[16]被变换完成。

2-4-5、组合变换后的R[16]L[16]（注意：R作为开始的32位），按下表（IP-1）变换得到最后的结果。

Final Permutation (IP**-1)

40 8 48 16 56 24 64 32

39 7 47 15 55 23 63 31

38 6 46 14 54 22 62 30

37 5 45 13 53 21 61 29

36 4 44 12 52 20 60 28

35 3 43 11 51 19 59 27

34 2 42 10 50 18 58 26

33 1 41 9 49 17 57 25

*/
